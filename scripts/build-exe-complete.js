/**
 * Complete EXE Build Script
 * Creates a single executable with all dependencies embedded
 * Memory principles: Full Modular Architecture, Thought Capsules
 * 
 * This script:
 * 1. Builds TypeScript to JavaScript
 * 2. Bundles all dependencies using esbuild
 * 3. Creates a single executable with nexe that includes:
 *    - All node_modules (embedded)
 *    - Frontend files (embedded)
 *    - Config template (embedded)
 * 4. First run extracts necessary files automatically
 */

import { execSync } from 'child_process';
import { existsSync, mkdirSync, readFileSync, writeFileSync, copyFileSync, readdirSync, statSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import esbuild from 'esbuild';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const projectRoot = join(__dirname, '..');

const buildDir = join(projectRoot, 'dist');
const outputDir = join(projectRoot, 'build');
const outputFile = join(outputDir, 'obs-multi-platform-streaming.exe');

console.log('ğŸš€ Building complete executable with all dependencies...\n');

/**
 * Recursively copy directory
 */
function copyDirectory(src, dest) {
  if (!existsSync(dest)) {
    mkdirSync(dest, { recursive: true });
  }
  
  const entries = readdirSync(src, { withFileTypes: true });
  
  for (const entry of entries) {
    const srcPath = join(src, entry.name);
    const destPath = join(dest, entry.name);
    
    if (entry.isDirectory()) {
      copyDirectory(srcPath, destPath);
    } else {
      copyFileSync(srcPath, destPath);
    }
  }
}

/**
 * Check if a command exists
 */
function commandExists(command) {
  try {
    execSync(`where ${command}`, { stdio: 'ignore' });
    return true;
  } catch {
    return false;
  }
}

async function buildExecutable() {
  try {
    // Step 1: Build TypeScript
    console.log('ğŸ“¦ Step 1: Building TypeScript...');
    if (!existsSync(buildDir)) {
      console.log('Running TypeScript compiler...');
      execSync('npm run build', { stdio: 'inherit', cwd: projectRoot });
    } else {
      console.log('âœ… TypeScript build already exists');
    }

    // Step 1.5: Create CommonJS bundle for pkg (pkg works better with CommonJS)
    console.log('\nğŸ“¦ Step 1.5: Creating CommonJS bundle for pkg...');
    const bundleFile = join(buildDir, 'bundle-nexe.js'); // Use .js extension for pkg compatibility
    
    // Use esbuild to create CommonJS bundle
    // Use source TypeScript file as entry point for better resolution
    try {
      await esbuild.build({
      entryPoints: [join(projectRoot, 'src', 'main.ts')],
      bundle: true,
      platform: 'node',
      target: 'node18',
      format: 'cjs', // CommonJS for nexe compatibility
      outfile: bundleFile,
      external: [
        // Native modules that nexe handles
        'fluent-ffmpeg',
        'node-media-server',
      ],
      resolveExtensions: ['.ts', '.js'],
      loader: {
        '.ts': 'ts',
      },
      sourcemap: false,
      minify: false,
      keepNames: true,
      banner: {
        js: `
// Bundle for pkg executable
// This file is auto-generated by build-exe-complete.js
if (typeof process !== 'undefined') {
  process.env.PKG_EXECUTABLE = 'true';
  process.env.EXECUTABLE_MODE = 'true';
}
`,
      },
    });
    console.log('âœ… CommonJS bundle created');
  } catch (error) {
    console.error('âŒ Failed to create bundle:', error);
    process.exit(1);
  }

  // Step 2: Check if bundle exists
  if (!existsSync(bundleFile)) {
    console.error('âŒ Error: Bundle file not found after esbuild.');
    process.exit(1);
  }

  // Step 3: Check if frontend exists
  const frontendDir = join(buildDir, 'ui', 'frontend');
  if (!existsSync(frontendDir)) {
    console.error('âŒ Error: dist/ui/frontend not found. Please run "npm run build" first.');
    process.exit(1);
  }

  // Step 4: Create build directory
  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true });
  }

  // Step 2: Check if pkg installation
  console.log('\nğŸ“¦ Step 2: Checking pkg installation...');
  let pkgInstalled = false;
  try {
    execSync('pkg --version', { stdio: 'ignore' });
    pkgInstalled = true;
    console.log('âœ… pkg is installed');
  } catch {
    console.log('âš ï¸  pkg not found globally, checking local installation...');
    try {
      const pkgPath = join(projectRoot, 'node_modules', '.bin', 'pkg');
      if (existsSync(pkgPath)) {
        pkgInstalled = true;
        console.log('âœ… pkg found in node_modules');
      }
    } catch {
      console.error('âŒ pkg not found. Installing...');
      execSync('npm install pkg --save-dev', { stdio: 'inherit', cwd: projectRoot });
      pkgInstalled = true;
    }
  }

  // Step 6: Prepare resources for nexe
  console.log('\nğŸ“¦ Step 3: Preparing resources...');
  
  // Create temp resources directory
  const tempResourcesDir = join(buildDir, 'nexe-resources');
  if (existsSync(tempResourcesDir)) {
    execSync(`rmdir /s /q "${tempResourcesDir}"`, { stdio: 'ignore', shell: true });
  }
  mkdirSync(tempResourcesDir, { recursive: true });
  
  // Copy frontend to temp resources
  const tempFrontendDir = join(tempResourcesDir, 'frontend');
  copyDirectory(frontendDir, tempFrontendDir);
  console.log('âœ… Frontend files prepared');
  
  // Copy config.yaml if exists
  const configSource = join(projectRoot, 'config.yaml');
  if (existsSync(configSource)) {
    copyFileSync(configSource, join(tempResourcesDir, 'config.yaml'));
    console.log('âœ… Config template prepared');
  }

  // Step 7: Build with pkg (more reliable, uses pre-built binaries)
  console.log('\nğŸ“¦ Step 4: Building executable with pkg...');
  console.log('pkg uses pre-built Node.js binaries - no build tools needed!\n');
  console.log('âš ï¸  Note: pkg will bundle all node_modules automatically\n');
  
  // pkg automatically bundles all dependencies
  // Use CommonJS bundle for better compatibility
  // pkg works better with CommonJS bundles
  const pkgArgs = [
    bundleFile,
    '--targets', 'node18-win-x64',
    '--output', outputFile,
    '--assets', `${tempResourcesDir}/**/*`
  ];

  // Use local pkg if available
  const pkgCommand = existsSync(join(projectRoot, 'node_modules', '.bin', 'pkg'))
    ? `"${join(projectRoot, 'node_modules', '.bin', 'pkg')}"`
    : 'pkg';

  // Build pkg command
  const pkgCmd = `${pkgCommand} ${pkgArgs.map(arg => {
    // Escape paths with spaces
    if (arg.includes(' ')) {
      return `"${arg}"`;
    }
    return arg;
  }).join(' ')}`;

  console.log(`Running: ${pkgCmd}\n`);
  
  try {
    execSync(pkgCmd, {
      stdio: 'inherit',
      cwd: projectRoot,
      shell: true
    });
  } catch (error) {
    console.error('\nâŒ pkg build failed');
    console.error('This might be due to:');
    console.error('1. pkg needs to download Node.js binaries (first time only)');
    console.error('2. Network issues downloading Node.js binaries');
    console.error('3. Check pkg installation: npm install pkg --save-dev');
    throw error;
  }
  
  // Step 8: Copy frontend files to build directory (for easy access)
  console.log('\nğŸ“¦ Step 5.5: Copying frontend files to build directory...');
  const buildFrontendDir = join(outputDir, 'frontend');
  if (existsSync(frontendDir)) {
    if (existsSync(buildFrontendDir)) {
      execSync(`rmdir /s /q "${buildFrontendDir}"`, { stdio: 'ignore', shell: true });
    }
    copyDirectory(frontendDir, buildFrontendDir);
    console.log('âœ… Frontend files copied to build directory');
  }

  // Step 8.5: Create config.yaml and logs directory in build folder
  console.log('\nğŸ“¦ Step 5.6: Creating config.yaml and logs directory...');
  const buildConfigFile = join(outputDir, 'config.yaml');
  const buildLogsDir = join(outputDir, 'logs');
  
  // Copy config.yaml if exists, otherwise create default
  const projectConfigFile = join(projectRoot, 'config.yaml');
  if (existsSync(projectConfigFile)) {
    copyFileSync(projectConfigFile, buildConfigFile);
    console.log('âœ… Config file copied to build directory');
  } else {
    // Create default config
    const defaultConfig = `version: 1.0.0
streamManager:
  obs:
    host: localhost
    port: 4455
    password: null
  rtmpServer:
    host: 0.0.0.0
    port: 1935
    appName: live
    streamKey: obs
    enabled: true
  autoReconnect: true
  reconnectDelay: 5
  maxReconnectAttempts: 10
  platforms: []
ui:
  host: 0.0.0.0
  port: 8000
  debug: false
`;
    writeFileSync(buildConfigFile, defaultConfig, 'utf-8');
    console.log('âœ… Default config file created in build directory');
  }
  
  // Create logs directory
  if (!existsSync(buildLogsDir)) {
    mkdirSync(buildLogsDir, { recursive: true });
    console.log('âœ… Logs directory created in build directory');
  }

  // Clean up temp resources directory
  if (existsSync(tempResourcesDir)) {
    try {
      execSync(`rmdir /s /q "${tempResourcesDir}"`, { stdio: 'ignore', shell: true });
    } catch {
      // Ignore cleanup errors
    }
  }

  // Step 9: Verify executable
  console.log('\nğŸ“¦ Step 6: Verifying executable...');
  if (existsSync(outputFile)) {
    const stats = statSync(outputFile);
    const sizeMB = (stats.size / (1024 * 1024)).toFixed(2);
    console.log(`âœ… Executable built successfully!`);
    console.log(`   File: ${outputFile}`);
    console.log(`   Size: ${sizeMB} MB`);
  } else {
    console.error('âŒ Executable not found after build');
    process.exit(1);
  }

  // Step 10: Create README
  console.log('\nğŸ“¦ Step 7: Creating documentation...');
  const readme = `# OBS Multi-Platform Streaming - Executable

## Kurulum

Bu executable tÃ¼m baÄŸÄ±mlÄ±lÄ±klarÄ± iÃ§erir. Ekstra kurulum gerekmez.

## KullanÄ±m

1. obs-multi-platform-streaming.exe dosyasÄ±na Ã§ift tÄ±klayÄ±n
2. Ä°lk aÃ§Ä±lÄ±ÅŸta gerekli dosyalar otomatik olarak yÃ¼klenecektir
3. TarayÄ±cÄ±nÄ±zda http://localhost:8000 adresine gidin

## YapÄ±landÄ±rma

Ä°lk Ã§alÄ±ÅŸtÄ±rmada config.yaml dosyasÄ± otomatik oluÅŸturulur.
Executable ile aynÄ± dizinde config.yaml dosyasÄ±nÄ± dÃ¼zenleyebilirsiniz.

## Ã–zellikler

- âœ… TÃ¼m baÄŸÄ±mlÄ±lÄ±klar executable iÃ§inde
- âœ… Ä°lk aÃ§Ä±lÄ±ÅŸta otomatik kurulum
- âœ… Frontend dosyalarÄ± otomatik yÃ¼klenir
- âœ… Config dosyasÄ± otomatik oluÅŸturulur
- âœ… Tek dosya, taÅŸÄ±nabilir

## Sistem Gereksinimleri

- Windows 10 veya Ã¼zeri
- FFmpeg (sistem PATH'inde olmalÄ± veya executable ile aynÄ± dizinde)

## Sorun Giderme

### Executable Ã§alÄ±ÅŸmÄ±yor
- Windows Defender veya antivirÃ¼s yazÄ±lÄ±mÄ± executable'Ä± engelliyor olabilir
- YÃ¶netici olarak Ã§alÄ±ÅŸtÄ±rmayÄ± deneyin

### Port hatasÄ±
- Port 8000, 1935 veya 8001 kullanÄ±mda olabilir
- Bu portlarÄ± kullanan uygulamalarÄ± kapatÄ±n

### FFmpeg hatasÄ±
- FFmpeg'in sistem PATH'inde olduÄŸundan emin olun
- Veya FFmpeg'i executable ile aynÄ± dizine kopyalayÄ±n

## Destek

Sorun yaÅŸarsanÄ±z, executable ile aynÄ± dizinde oluÅŸturulan logs klasÃ¶rÃ¼ndeki log dosyalarÄ±nÄ± kontrol edin.
`;

  writeFileSync(join(outputDir, 'README.txt'), readme, 'utf-8');
  console.log('âœ… Documentation created');

  // Step 11: Summary
  console.log('\n' + '='.repeat(60));
  console.log('âœ… BUILD COMPLETE!');
  console.log('='.repeat(60));
  console.log(`\nğŸ“¦ Executable: ${outputFile}`);
  console.log(`ğŸ“„ Documentation: ${join(outputDir, 'README.txt')}`);
  console.log('\nğŸ’¡ Next steps:');
  console.log('   1. Test the executable by double-clicking it');
  console.log('   2. Check http://localhost:8000 in your browser');
  console.log('   3. Configure platforms through the web interface');
  console.log('\nğŸ‰ All dependencies are embedded in the executable!');
  console.log('   First run will automatically extract necessary files.\n');

  } catch (error) {
    console.error('\nâŒ Build failed:', error.message);
    console.error('\nTroubleshooting:');
    console.error('1. Make sure TypeScript is compiled: npm run build');
    console.error('2. Make sure nexe is installed: npm install nexe --save-dev');
    console.error('3. Check if Node.js 18.0.0 is available');
    console.error('4. Check if dist/main.js exists');
    console.error('5. Check if dist/ui/frontend exists');
    process.exit(1);
  }
}

// Run the build
buildExecutable();

